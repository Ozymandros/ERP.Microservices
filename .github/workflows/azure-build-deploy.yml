name: Build & Deploy ERP Services to Azure

on:
  push:
    branches: [main, develop]
  workflow_dispatch:

env:
  AZURE_ENV_NAME: "dev"
  AZURE_LOCATION: "westeurope"

jobs:
  provision-infrastructure:
    name: Provision Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      id-token: write
    env:
      # Dapr configuration - Aspire reads DaprCliPath from environment
      DaprCliPath: /usr/local/bin/dapr
      DAPR_HOME: /home/runner/.dapr

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Azure and Azure Developer CLI
        uses: ./.github/actions/setup-azure-azd
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Dapr CLI
        uses: dapr/setup-dapr@v1
        with:
          version: "1.12.0"

      - name: Validate and Configure Dapr CLI for Aspire
        run: |
          echo "Validating Dapr CLI installation..."
          dapr --version || {
            echo "ERROR: Dapr CLI not found after installation"
            exit 1
          }

          # Find where dapr is installed
          DAPR_PATH=$(which dapr)
          echo "Dapr CLI found at: $DAPR_PATH"

          # Update DaprCliPath environment variable for Aspire
          # Aspire reads DaprCliPath from environment
          echo "DaprCliPath=$DAPR_PATH" >> $GITHUB_ENV

          # Initialize Dapr in slim mode (required for Aspire)
          echo "Initializing Dapr runtime..."
          dapr init --slim

          # Verify initialization
          echo "✓ Dapr CLI installed and initialized successfully"
          echo "✓ DaprCliPath set to: $DAPR_PATH"

      - name: Force create azd environment context
        run: |
          # This creates the minimal configuration so azd doesn't say "does not exist"
          azd env new ${{ env.AZURE_ENV_NAME }} --location ${{ env.AZURE_LOCATION }} --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        continue-on-error: true

      - name: Refresh environment from Azure
        run: |
          # This brings the real values from Azure to the GitHub runner
          azd env refresh --environment ${{ env.AZURE_ENV_NAME }}

      - name: Configure azd to use Azure CLI credentials
        run: |
          echo "Configuring azd to use Azure CLI credentials..."
          # azd will use Azure CLI credentials when AZURE_CLIENT_ID is set
          export AZURE_CLIENT_ID=${{ secrets.AZURE_CLIENT_ID }}
          export AZURE_TENANT_ID=${{ secrets.AZURE_TENANT_ID }}
          export AZURE_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID }}

          # Verify Azure CLI is authenticated
          az account show || {
            echo "ERROR: Azure CLI is not authenticated"
            exit 1
          }

          # Configure azd to use Azure CLI credentials
          azd config set auth.useAzCliAuth true

      - name: Preview Infrastructure Provisioning (Required)
        env:
          AZURE_ENV_NAME: ${{ env.AZURE_ENV_NAME }}
          AZURE_LOCATION: ${{ env.AZURE_LOCATION }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          echo "Previewing infrastructure changes..."
          azd provision --preview
          echo "Preview successful. Proceeding with provisioning..."

      - name: Provision Infrastructure
        env:
          AZURE_ENV_NAME: ${{ env.AZURE_ENV_NAME }}
          AZURE_LOCATION: ${{ env.AZURE_LOCATION }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          echo "Provisioning infrastructure..."
          azd provision --no-prompt

      - name: Get Registry Name
        id: registry
        env:
          AZURE_ENV_NAME: ${{ env.AZURE_ENV_NAME }}
        run: |
          # Refresh environment to ensure variables are loaded
          azd env refresh --environment $AZURE_ENV_NAME

          # Try to read directly from environment first
          REGISTRY_NAME="${AZURE_CONTAINER_REGISTRY_NAME:-}"

          # If not found, get it from azd
          if [ -z "$REGISTRY_NAME" ]; then
            REGISTRY_NAME=$(azd env get-value AZURE_CONTAINER_REGISTRY_NAME --environment $AZURE_ENV_NAME)
          fi

          if [ -z "$REGISTRY_NAME" ]; then
            echo "ERROR: AZURE_CONTAINER_REGISTRY_NAME not found"
            exit 1
          fi

          echo "✓ Registry name obtained: $REGISTRY_NAME"
          echo "registry_name=$REGISTRY_NAME" >> $GITHUB_OUTPUT

    outputs:
      registry_name: ${{ steps.registry.outputs.registry_name }}

  build-and-push-images:
    name: Build Docker Images
    needs: provision-infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 45
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Azure and Azure Developer CLI
        uses: ./.github/actions/setup-azure-azd
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Use Registry Name from Provision Job
        run: |
          REGISTRY_NAME="${{ needs.provision-infrastructure.outputs.registry_name }}"
          if [ -z "$REGISTRY_NAME" ]; then
            echo "ERROR: Registry name not available from provision job!"
            exit 1
          fi
          echo "✓ Using registry: $REGISTRY_NAME"
          echo "REGISTRY_NAME=$REGISTRY_NAME" >> $GITHUB_ENV

      - name: Login to ACR
        run: az acr login --name ${{ needs.provision-infrastructure.outputs.registry_name }}

      # Build and push shared base image FIRST (required by Inventory, Billing, Orders, Purchasing, Sales)
      - name: Build and push shared base image
        run: |
          IMAGE_TAG=${GITHUB_SHA::7}
          REGISTRY_NAME="${{ needs.provision-infrastructure.outputs.registry_name }}"
          echo "Building shared base image with tag: $IMAGE_TAG"

          az acr build \
            --registry $REGISTRY_NAME \
            --image "myapp-microservices-base:$IMAGE_TAG" \
            --image "myapp-microservices-base:10.0" \
            --image "myapp-microservices-base:latest" \
            --file docker/microservices-base.Dockerfile \
            .

          # Verify base image was built successfully
          # If az acr build succeeds, the tags should be available
          echo "✓ Base image build completed successfully"

      # Build and push all service images
      - name: Build and push service images to ACR
        run: |
          # Define services to build (path relative to src/, image name)
          declare -a SERVICES=(
              "MyApp.Auth/MyApp.Auth.API:auth-service"
              "MyApp.Billing/MyApp.Billing.API:billing-service"
              "MyApp.Inventory/MyApp.Inventory.API:inventory-service"
              "MyApp.Orders/MyApp.Orders.API:orders-service"
              "MyApp.Purchasing/MyApp.Purchasing.API:purchasing-service"
              "MyApp.Sales/MyApp.Sales.API:sales-service"
              "ErpApiGateway:erp-api-gateway"
          )

          # Get Git commit hash for image tag
          IMAGE_TAG=${GITHUB_SHA::7}
          REGISTRY_NAME="${{ needs.provision-infrastructure.outputs.registry_name }}"

          # Get registry endpoint from azd environment (already available after provision)
          BASE_IMAGE_REGISTRY="${AZURE_CONTAINER_REGISTRY_ENDPOINT:-}"
          if [ -z "$BASE_IMAGE_REGISTRY" ]; then
            BASE_IMAGE_REGISTRY=$(azd env get-value AZURE_CONTAINER_REGISTRY_ENDPOINT --environment $AZURE_ENV_NAME)
          fi
          # Add trailing slash for Dockerfile FROM statement
          BASE_IMAGE_REGISTRY="${BASE_IMAGE_REGISTRY}/"

          echo "Building service images with tag: $IMAGE_TAG"

          for SERVICE in "${SERVICES[@]}"; do
              IFS=':' read -r SERVICE_PATH IMAGE_NAME <<< "$SERVICE"
              echo "Building: $IMAGE_NAME from src/$SERVICE_PATH"
              
              # Check if this service uses the shared base image (all except auth-service and erp-api-gateway)
              if [[ "$IMAGE_NAME" != "auth-service" && "$IMAGE_NAME" != "erp-api-gateway" ]]; then
                  # Pass registry endpoint as build arg for base image resolution
                  az acr build \
                      --registry $REGISTRY_NAME \
                      --image "$IMAGE_NAME:$IMAGE_TAG" \
                      --image "$IMAGE_NAME:latest" \
                      --file "src/$SERVICE_PATH/Dockerfile" \
                      --build-arg BASE_IMAGE_REGISTRY="$BASE_IMAGE_REGISTRY" \
                      .
              else
                  # Auth and Gateway don't use shared base image
                  # Use root context (.) and add src/ prefix to Dockerfile path
                  az acr build \
                      --registry $REGISTRY_NAME \
                      --image "$IMAGE_NAME:$IMAGE_TAG" \
                      --image "$IMAGE_NAME:latest" \
                      --file "src/$SERVICE_PATH/Dockerfile" \
                      .
              fi
          done

      - name: Verify images in ACR
        run: |
          REGISTRY_NAME="${{ needs.provision-infrastructure.outputs.registry_name }}"

          echo "=== All Images in ACR ==="
          az acr repository list --name $REGISTRY_NAME --output table

          echo ""
          echo "=== Base Image Tags ==="
          az acr repository show-tags --name $REGISTRY_NAME --repository myapp-microservices-base --output table || echo "Base image not found"

          echo ""
          echo "=== Service Image Tags ==="
          for IMAGE in auth-service billing-service inventory-service orders-service purchasing-service sales-service erp-api-gateway; do
              echo "Tags for $IMAGE:"
              az acr repository show-tags --name $REGISTRY_NAME --repository $IMAGE --output table --top 3 || echo "  Image $IMAGE not found"
              echo ""
          done

          echo "=== Build Summary ==="
          IMAGE_TAG=${GITHUB_SHA::7}
          echo "Built images with tag: $IMAGE_TAG"
          echo "- myapp-microservices-base:$IMAGE_TAG"
          echo "- auth-service:$IMAGE_TAG"
          echo "- billing-service:$IMAGE_TAG"
          echo "- inventory-service:$IMAGE_TAG"
          echo "- orders-service:$IMAGE_TAG"
          echo "- purchasing-service:$IMAGE_TAG"
          echo "- sales-service:$IMAGE_TAG"
          echo "- erp-api-gateway:$IMAGE_TAG"

  deploy-to-azure:
    name: Deploy Application
    needs: build-and-push-images
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      id-token: write
    env:
      # Dapr configuration - Aspire reads DaprCliPath from environment
      # Will be updated after Dapr installation to point to actual location
      DaprCliPath: /usr/local/bin/dapr
      DAPR_HOME: /home/runner/.dapr

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Azure and Azure Developer CLI
        uses: ./.github/actions/setup-azure-azd
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Dapr CLI
        uses: dapr/setup-dapr@v1
        with:
          version: "1.12.0"

      - name: Validate and Configure Dapr CLI for Aspire
        run: |
          echo "Validating Dapr CLI installation..."
          dapr --version || {
            echo "ERROR: Dapr CLI not found after installation"
            exit 1
          }

          # Find where dapr is installed
          DAPR_PATH=$(which dapr)
          echo "Dapr CLI found at: $DAPR_PATH"

          # Update DaprCliPath environment variable for Aspire
          echo "DaprCliPath=$DAPR_PATH" >> $GITHUB_ENV

          # Initialize Dapr in slim mode (required for Aspire)
          echo "Initializing Dapr runtime..."
          dapr init --slim

          # Verify initialization
          echo "✓ Dapr CLI installed and initialized successfully"
          echo "✓ DaprCliPath set to: $DAPR_PATH"

      - name: Set up dotnet
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"

      - name: Deploy Application
        env:
          AZURE_ENV_NAME: ${{ env.AZURE_ENV_NAME }}
          AZURE_LOCATION: ${{ env.AZURE_LOCATION }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          # Use short commit hash to match image tags (first 7 characters)
          export IMAGE_TAG=${GITHUB_SHA::7}
          echo "Deploying with image tag: $IMAGE_TAG"
          azd deploy --no-prompt

  verify-deployment:
    name: Verify Deployment
    needs: deploy-to-azure
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Azure login (Federated)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Check Container Apps status
        run: |
          RG_NAME="rg-myapp-${{ env.AZURE_ENV_NAME }}-core"

          echo "Checking Container Apps health..."
          az containerapp list --resource-group "$RG_NAME" --output table

          echo ""
          echo "Checking revision status..."
          for APP in auth-service billing-service inventory-service orders-service purchasing-service sales-service api-gateway; do
              echo ""
              echo "App: myapp-${{ env.AZURE_ENV_NAME }}-$APP"
              az containerapp show --name "myapp-${{ env.AZURE_ENV_NAME }}-$APP" \
                  --resource-group "$RG_NAME" \
                  --query "properties.latestRevisionFqdn" -o tsv || echo "Not found"
          done

      - name: Run smoke tests
        run: |
          echo "✓ Deployment verified successfully"
